<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>TWICE â¤ï¸ ONCE I GOCHA</title>
  <style>
    :root {
      --primary: #ff6f91;
      --secondary: #ff9671;
      --accent: #d65db1;
      --bg: #fff0f5;
      
      /* === å°ºå¯¸è¨­å®š === */
      --item-height: 100px; 
      /* é¡¯ç¤ºå€é«˜åº¦ 3æ ¼ */
      --slot-view-height: calc(var(--item-height) * 3);
    }

    body {
      font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
      background-color: var(--bg);
      background-image: radial-gradient(var(--secondary) 1px, transparent 1px);
      background-size: 20px 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 10px;
      overflow-x: hidden;
    }

    .container {
      width: 100%;
      max-width: 500px;
      text-align: center;
      position: relative;
    }

    /* è¼¸å…¥å€ */
    #start-screen {
      background: white;
      padding: 30px 20px;
      border-radius: 25px;
      box-shadow: 0 10px 30px rgba(214, 93, 177, 0.2);
      border: 3px solid white;
      position: relative;
      z-index: 20;
    }

    h1 { 
      color: var(--accent); 
      margin-top: 0; 
      font-size: 1.6rem; 
      margin-bottom: 10px;
      line-height: 1.3;
    }

    .promo-link {
      display: inline-block;
      margin-bottom: 20px;
      color: var(--primary);
      text-decoration: none;
      font-size: 0.95rem;
      font-weight: bold;
      border-bottom: 2px dashed var(--primary);
      padding-bottom: 2px;
    }

    /* === æ–°å¢ï¼šåº«å­˜é¡¯ç¤ºå€ === */
    #stock-area {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }
    .stock-badge {
      background: #fce4ec;
      border: 1px solid #f8bbd0;
      color: #c2185b;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.85rem;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .stock-badge span {
      background: white;
      padding: 1px 6px;
      border-radius: 10px;
      margin-left: 5px;
      color: var(--primary);
    }
    
    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      padding: 15px;
      font-size: 1.4rem;
      border: 3px solid #eee;
      border-radius: 15px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--accent);
      outline: none;
      margin-bottom: 20px;
    }
    input:focus { border-color: var(--primary); }

    .btn-draw {
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      padding: 15px 0;
      width: 100%;
      font-size: 1.2rem;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(255, 111, 145, 0.4);
      transition: 0.2s;
    }
    .btn-draw:disabled { background: #ccc; cursor: wait; transform: none; box-shadow: none; }

    /* === æ‹‰éœ¸æ©Ÿå€åŸŸ === */
    #slot-machine-area {
      display: none;
      background: var(--accent);
      padding: 15px;
      border-radius: 20px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
      position: relative;
    }

    .machine-status {
      color: white;
      font-size: 1.2rem;
      margin-bottom: 15px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      min-height: 1.5em;
    }

    .slot-container {
      display: flex;
      justify-content: space-between;
      gap: 5px;
      background: #222;
      padding: 5px;
      border-radius: 10px;
      border: 5px solid #ffccbc;
      height: var(--slot-view-height);
      overflow: hidden;
      position: relative;
    }

    .win-line-svg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10;
      pointer-events: none;
    }
    .win-path {
      stroke: rgba(255, 0, 0, 0.8);
      stroke-width: 8;
      stroke-linecap: round;
      fill: none;
      filter: drop-shadow(0 0 5px red);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .win-path.show { opacity: 1; }

    .slot-container::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; height: 30%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.2), transparent);
      pointer-events: none;
      z-index: 5;
    }

    .reel {
      background: white;
      flex: 1;
      position: relative;
      overflow: hidden;
      border-radius: 4px;
    }

    .reel-strip {
      position: absolute;
      top: 0; left: 0; width: 100%;
      will-change: transform;
    }

    /* å¼·åˆ¶è¨­å®š box-sizing å’Œé«˜åº¦ï¼Œé¿å…ç©ºéš™ */
    .slot-item {
      height: var(--item-height);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-sizing: border-box; 
      border-bottom: 1px solid #eee;
      padding: 5px;
      overflow: hidden;
      background: white; /* ç¢ºä¿èƒŒæ™¯æ˜¯ç™½çš„ï¼Œä¸æ˜¯é€æ˜ */
    }

    .slot-img {
      width: 100%;
      height: 80%;
      object-fit: contain;
    }
    .slot-text {
      font-size: 0.8rem;
      color: #333;
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    /* === çµæœå½ˆçª— === */
    #result-card {
      display: none;
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 25px;
      width: 85%; max-width: 400px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      z-index: 999;
      animation: popIn 0.5s cubic-bezier(0.17, 0.67, 0.43, 1.45);
      text-align: center;
    }
    #overlay {
      display: none;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      z-index: 998;
      backdrop-filter: blur(3px);
    }
    
    .final-prize-img {
      width: 100%;
      max-height: 250px;
      object-fit: contain;
      border: 3px solid var(--primary);
      border-radius: 10px;
      margin-bottom: 10px;
    }

    .status-msg { margin-top: 10px; color: var(--primary); font-weight: bold; font-size: 0.9rem; }
    .error { color: #e53935; }

    @media screen and (max-width: 600px) {
      :root { --item-height: 80px; }
      .slot-text { font-size: 0.7rem; }
      h1 { font-size: 1.4rem; }
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
  </style>
</head>
<body>

  <div id="overlay"></div>

  <div class="container">
    
    <div id="start-screen">
      <h1>TWICE â¤ï¸ ONCE I GOCHA</h1>
      
      <a href="https://www.threads.com/@a27689532/post/DRlXgWvkiG9?xmt=AQF0m11o5sqKyTq1bZQteVidEod1mjd1eYCTce4RUaumCg" 
         target="_blank" 
         class="promo-link">
         ğŸŒŸ å°åŒ—å¤§å·¨è›‹é€±äº”å ´ç·šä¸Šæ‡‰æ´æ–‡ç«  ğŸŒŸ
      </a>
      
      <div id="stock-area">è¼‰å…¥åº«å­˜ä¸­...</div>

      <p style="color:#888; font-size:0.9rem; margin-top:10px;">è¼¸å…¥åºè™Ÿé–‹å§‹è½‰å‹•å¹¸é‹</p>
      
      <input type="text" id="code-input" placeholder="è«‹è¼¸å…¥åºè™Ÿ" maxlength="8" autocomplete="off">
      <button id="draw-btn" class="btn-draw">é–‹å§‹æŠ½ç</button>
      
      <div id="msg-box" class="status-msg"></div>
      <div id="loading-hint" style="display:none; color:#aaa; font-size:0.8rem; margin-top:5px;">æ­£åœ¨ä¸‹è¼‰åœ–ç‰‡ç´ æ...</div>
    </div>

    <div id="slot-machine-area">
      <div id="machine-status" class="machine-status">æº–å‚™å•Ÿå‹•...</div>
      
      <div class="slot-container">
        <svg class="win-line-svg" viewBox="0 0 300 300" preserveAspectRatio="none">
           <path id="win-path" class="win-path" d="" />
        </svg>

        <div class="reel"><div class="reel-strip" id="reel-1"></div></div>
        <div class="reel"><div class="reel-strip" id="reel-2"></div></div>
        <div class="reel"><div class="reel-strip" id="reel-3"></div></div>
      </div>
    </div>

    <div id="result-card">
      <h2 style="color:var(--secondary); margin:0 0 10px 0;">ğŸ‰ CONGRATULATIONS!</h2>
      <img id="final-img" class="final-prize-img" src="" alt="Prize">
      <h3 id="final-name" style="color:var(--accent); margin:5px 0;"></h3>
      <p id="final-detail" style="color:#666; margin:5px 0;"></p>
      <div style="background:#eee; padding:5px; border-radius:5px; display:inline-block; margin-top:10px;">
        <span style="font-size:0.8rem;">åºè™Ÿ: </span>
        <strong id="final-code" style="color:#555;"></strong>
      </div>
      <br>
      <button onclick="resetGame()" class="btn-draw" style="margin-top:20px; padding:10px 30px;">å†ç©ä¸€æ¬¡</button>
    </div>

  </div>

  <script>
    // â˜…â˜…â˜… è«‹æ›¿æ›æˆæ‚¨çš„ GAS ç¶²å€ â˜…â˜…â˜…
    const API_URL = 'https://script.google.com/macros/s/AKfycbyfF-yGRiOaEwTfb46Riji-ERnQqjhPL_uJ5rVeekGvI1j4-hmfPu3Jr4MkdeqhfcyHtw/exec';

    // å…¨åŸŸè³‡æ–™
    let CATALOG = { 
      types: {}, 
      relations: {},
      stocks: {} // å„²å­˜åº«å­˜è³‡æ–™
    };
    
    const DEFAULT_TYPES = ['é›¨å‚˜å¨ƒ', 'ä¸‰éº—é·—', 'é¾è¦æ‰£', 'è»Ÿç³–', 'å·§å…‹åŠ›', 'é¤…ä¹¾', 'è»Šè»Š', 'æ¨¡å‹åŒ…'];
    const DEFAULT_LOVELYS = ['SAVELY', 'TZUVELY', 'MIVELY', 'JIVELY', 'CHAENG', 'DAHYUN', 'NAYEON', 'JEONG'];

    const WIN_PATTERNS = [
      { name: 'MIDDLE', rows: [1, 1, 1], svg: 'M0,150 L300,150' },
      { name: 'TOP',    rows: [0, 0, 0], svg: 'M0,50 L300,50' },
      { name: 'BOTTOM', rows: [2, 2, 2], svg: 'M0,250 L300,250' },
      { name: 'DIAG_TL',rows: [0, 1, 2], svg: 'M0,50 L300,250' },
      { name: 'DIAG_BL',rows: [2, 1, 0], svg: 'M0,250 L300,50' }
    ];

    const drawBtn = document.getElementById('draw-btn');
    const codeInput = document.getElementById('code-input');
    const msgBox = document.getElementById('msg-box');
    const startScreen = document.getElementById('start-screen');
    const slotArea = document.getElementById('slot-machine-area');
    const machineStatus = document.getElementById('machine-status');
    const resultCard = document.getElementById('result-card');
    const overlay = document.getElementById('overlay');
    const loadingHint = document.getElementById('loading-hint');
    const winPath = document.getElementById('win-path');
    const stockArea = document.getElementById('stock-area');

    window.onload = function() { fetchCatalog(); };

    function fetchCatalog() {
      loadingHint.style.display = 'block';
      drawBtn.disabled = true;

      fetch(API_URL + '?action=catalog')
        .then(res => res.json())
        .then(data => {
          if(data.ok) {
            processCatalog(data);
            renderStocks(); // ç¹ªè£½åº«å­˜
            loadingHint.style.display = 'none';
            drawBtn.disabled = false;
          } else {
            loadingHint.textContent = 'ä½¿ç”¨ç´”æ–‡å­—æ¨¡å¼';
            stockArea.textContent = 'åº«å­˜è³‡è¨Šç„¡æ³•è¼‰å…¥';
            drawBtn.disabled = false;
          }
        })
        .catch(err => {
          loadingHint.textContent = 'é€£ç·šç•°å¸¸';
          drawBtn.disabled = false;
        });
    }

    function processCatalog(data) {
      if (data.typeImages) {
        for (const [type, imgs] of Object.entries(data.typeImages)) {
          if (imgs && imgs.length > 0) CATALOG.types[type] = imgs;
        }
      }
      if (data.typeLovelyImages) {
        CATALOG.relations = data.typeLovelyImages;
      }
      // è™•ç†åº«å­˜
      if (data.typeStocks) {
        CATALOG.stocks = data.typeStocks;
      }
    }

    function renderStocks() {
      stockArea.innerHTML = '';
      if (Object.keys(CATALOG.stocks).length === 0) {
        stockArea.textContent = 'ç›®å‰æ²’æœ‰åº«å­˜è³‡æ–™';
        return;
      }
      
      // æ’åºä¸¦é¡¯ç¤º
      for (const [type, count] of Object.entries(CATALOG.stocks)) {
        if (count > 0) {
          const badge = document.createElement('div');
          badge.className = 'stock-badge';
          badge.innerHTML = `${type} <span>${count}</span>`;
          stockArea.appendChild(badge);
        }
      }
    }

    drawBtn.addEventListener('click', startProcess);
    codeInput.addEventListener('keypress', (e) => { if(e.key==='Enter') startProcess(); });

    function resetGame() {
      resultCard.style.display = 'none';
      overlay.style.display = 'none';
      slotArea.style.display = 'none';
      startScreen.style.display = 'block';
      codeInput.value = '';
      msgBox.textContent = '';
      drawBtn.disabled = false;
      drawBtn.textContent = 'é–‹å§‹æŠ½ç';
    }

    function startProcess() {
      const code = codeInput.value.trim().toUpperCase();
      if(!code) return showMsg('è«‹è¼¸å…¥åºè™Ÿ', 'error');

      codeInput.blur();
      drawBtn.disabled = true;
      drawBtn.textContent = 'é©—è­‰åºè™Ÿä¸­...';
      showMsg('', 'normal');

      fetch(API_URL, {
        method: 'POST',
        body: JSON.stringify({ action: 'draw', code: code })
      })
      .then(res => res.json())
      .then(data => {
        if(data.ok) {
          startScreen.style.display = 'none';
          slotArea.style.display = 'block';
          setTimeout(() => slotArea.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
          
          runSlotAnimation(data);
        } else {
          showMsg(data.message, 'error');
          drawBtn.disabled = false;
          drawBtn.textContent = 'é–‹å§‹æŠ½ç';
        }
      })
      .catch(err => {
        showMsg('ç¶²è·¯éŒ¯èª¤', 'error');
        drawBtn.disabled = false;
        drawBtn.textContent = 'é–‹å§‹æŠ½ç';
      });
    }

    async function runSlotAnimation(data) {
      const pattern = WIN_PATTERNS[Math.floor(Math.random() * WIN_PATTERNS.length)];
      winPath.setAttribute('d', pattern.svg);
      winPath.classList.remove('show'); 

      const typeKeys = Object.keys(CATALOG.types).length > 0 ? Object.keys(CATALOG.types) : DEFAULT_TYPES;
      
      machineStatus.textContent = 'âœ¨ æŠ½é¸ç¨®é¡ä¸­... âœ¨';
      await spinAllReels(typeKeys, data.type, 'TYPE', pattern, null);

      winPath.classList.add('show');
      await wait(1000);
      winPath.classList.remove('show');

      let colorKeys = DEFAULT_LOVELYS;
      if (CATALOG.relations[data.type]) {
        const keys = Object.keys(CATALOG.relations[data.type]);
        if (keys.length > 0) colorKeys = keys;
      }

      machineStatus.textContent = 'ğŸ’– å¬å–š LOVELYS... ğŸ’–';
      machineStatus.style.color = '#ffeb3b';
      
      const pattern2 = WIN_PATTERNS[Math.floor(Math.random() * WIN_PATTERNS.length)];
      winPath.setAttribute('d', pattern2.svg);
      
      await spinAllReels(colorKeys, data.color, 'COLOR', pattern2, data.type);

      winPath.classList.add('show');
      await wait(800);
      
      showFinalResult(data);
    }

    function spinAllReels(poolKeys, targetText, mode, pattern, contextType) {
      return new Promise(resolve => {
        const reels = [
          document.getElementById('reel-1'),
          document.getElementById('reel-2'),
          document.getElementById('reel-3')
        ];
        const durations = [3000, 4500, 6000];
        const style = getComputedStyle(document.documentElement);
        const itemHeight = parseInt(style.getPropertyValue('--item-height')) || 100;

        spinOneReel(reels[0], poolKeys, targetText, mode, durations[0], itemHeight, pattern.rows[0], null, contextType);
        spinOneReel(reels[1], poolKeys, targetText, mode, durations[1], itemHeight, pattern.rows[1], null, contextType);
        spinOneReel(reels[2], poolKeys, targetText, mode, durations[2], itemHeight, pattern.rows[2], resolve, contextType);
      });
    }

    function spinOneReel(element, pool, target, mode, duration, itemHeight, targetRowIndex, callback, contextType) {
      let html = '';
      const count = 40; 

      for(let i=0; i<count; i++) {
        const randomKey = pool[Math.floor(Math.random() * pool.length)];
        const imgUrl = getRandomImg(mode, randomKey, contextType);
        html += createSlotItemHtml(randomKey, imgUrl);
      }

      // === çµæ§‹å„ªåŒ–ï¼šé˜²æ­¢ç©ºç™½ ===
      // ä¸Šæ–¹è£é£¾ (1å€‹)
      const prevKey = pool[Math.floor(Math.random() * pool.length)];
      html += createSlotItemHtml(prevKey, getRandomImg(mode, prevKey, contextType));

      // â˜… ç›®æ¨™ (ç´¢å¼• count+1)
      html += createSlotItemHtml(target, getRandomImg(mode, target, contextType));

      // ä¸‹æ–¹è£é£¾ (å¢åŠ åˆ° 3 å€‹ï¼Œç¢ºä¿å°±ç®—åœåœ¨æœ€ä¸‹é¢ï¼Œä¸‹é¢é‚„æœ‰æ±è¥¿)
      for(let k=0; k<3; k++) {
        const nextKey = pool[Math.floor(Math.random() * pool.length)];
        html += createSlotItemHtml(nextKey, getRandomImg(mode, nextKey, contextType));
      }

      element.innerHTML = html;
      
      element.style.transition = 'none';
      element.style.transform = 'translateY(0)';
      element.offsetHeight; 

      const finalY = (targetRowIndex * itemHeight) - ((count + 1) * itemHeight);

      element.style.transition = `transform ${duration}ms cubic-bezier(0.15, 0.9, 0.30, 1)`;
      element.style.transform = `translateY(${finalY}px)`;

      if(callback) {
        setTimeout(callback, duration);
      }
    }

    function getRandomImg(mode, key, contextType) {
      if (mode === 'TYPE') {
        const arr = CATALOG.types[key];
        if (arr && arr.length > 0) return arr[Math.floor(Math.random() * arr.length)];
      } 
      else if (mode === 'COLOR') {
        if (contextType && CATALOG.relations[contextType]) {
          const arr = CATALOG.relations[contextType][key];
          if (arr && arr.length > 0) return arr[Math.floor(Math.random() * arr.length)];
        }
      }
      return '';
    }

    function createSlotItemHtml(text, imgUrl) {
      let content = '';
      if (imgUrl) {
        content = `<img src="${imgUrl}" class="slot-img" alt="${text}"><div class="slot-text">${text}</div>`;
      } else {
        content = `<div style="font-size:1.5rem; color:#d65db1;">${text}</div>`;
      }
      return `<div class="slot-item">${content}</div>`;
    }

    function showFinalResult(data) {
      document.getElementById('final-name').textContent = data.display_name;
      document.getElementById('final-detail').textContent = `${data.type} / ${data.color}`;
      document.getElementById('final-code').textContent = data.prize_key;

      const img = document.getElementById('final-img');
      if(data.image_url) {
        img.src = data.image_url;
        img.style.display = 'block';
      } else {
        img.style.display = 'none';
      }

      // === å‰ç«¯å³æ™‚æ‰£åº«å­˜ (ä¸ç”¨é‡æ–°æ•´ç†) ===
      if (CATALOG.stocks[data.type]) {
        CATALOG.stocks[data.type]--;
        if (CATALOG.stocks[data.type] < 0) CATALOG.stocks[data.type] = 0;
        renderStocks(); // é‡æ–°ç¹ªè£½åº«å­˜æ¨™ç±¤
      }

      overlay.style.display = 'block';
      resultCard.style.display = 'block';
    }

    function showMsg(text, type) {
      msgBox.textContent = text;
      msgBox.className = 'status-msg ' + (type === 'error' ? 'error' : '');
    }

    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
  </script>
</body>
</html>
